

# 1. 15829 - Hashing (https://www.acmicpc.net/problem/15829)
"""
문제 설명
해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져있다. 다들 비둘기 집의 원리에 대해서는 한 번쯤 들어봤을 것이다.
그 원리에 의하면 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다. 이를 해시 충돌이라고 하는데, 좋은 해시 함수는 최대한 충돌이 적게 일어나야 한다.
위에서 정의한 해시 함수는 알파벳의 순서만 바꿔도 충돌이 일어나기 때문에 나쁜 해시 함수이다. 그러니까 조금 더 개선해보자.
"""

# 내 풀이
L = int(input())
char = str(input())

result = 0
for i, j in zip(range(0, L), char) :
    result += (ord(j) - 96) * 31 ** i

print(result % 1234567891)

"""
insight 정리
1. Hashing의 개념과 원리에 대해 상기시키기. 특히 마지막 print문에 붙은 % 1234567891이 어떤 목적을 갖고 있는지 꼭 기억하기
2. 해시 충돌을 방지하기 위해 어떤 조치를 취할 수 있는지, 이때 주의해야 할 사항(값의 설정)은 무엇이 있는지 기억하기
"""

# ----------------------------------------------------------------------------

# 2. 10250 - ACM 호텔 (https://www.acmicpc.net/problem/10250)
"""
문제 설명
ACM 호텔 매니저 지우는 손님이 도착하는 대로 빈 방을 배정하고 있다.
고객 설문조사에 따르면 손님들은 호텔 정문으로부터 걸어서 가장 짧은 거리에 있는 방을 선호한다고 한다.
여러분은 지우를 도와 줄 프로그램을 작성하고자 한다.
즉 설문조사 결과 대로 호텔 정문으로부터 걷는 거리가 가장 짧도록 방을 배정하는 프로그램을 작성하고자 한다.
"""

# 내 풀이
T = int(input())
for _ in range(T) :
    H, W, N = map(int, input().split())
    if len(str(W)) > len(str(N // H)) :
        print(int(str(N % H) + str('0' * (len(str(W)) - len(str(N // H))) + str((N // H) + 1))))
    else :
        print(int(str(N % H) + str((N // H) + 1)))

# Case Study
t = int(input())
for i in range(t) :
    h, w, n = map(int, input().split())
    num = n // h + 1
    floor = n % h
    if n % h == 0 :
        num = n // h
        floor = h
    print(f"{floor * 100 + num}")


"""
insight 정리
1. 순서 / 높이의 몫은 호수의 뒷자리, 나머지는 호수의 앞자리를 결정한다는 것은 이해했지만, 최종 방 호수를 출력하는 과정에서 불필요한 수식과 조건을 많이 추가함
-> 나머지가 0이 아닐 때 / 나머지가 0일 때에 대한 케이스 구분 + floor에 * 100을 곱하여 최종 출력 (문제 조건에 따라 100을 곱하는 것만으로 커버가 가능했음)
2. 문제 풀기 전에 세부 Task 구분을 최대한 고민하기
"""

# ----------------------------------------------------------------------------

# 3. 2869 - 달팽이는 올라가고 싶다 (https://www.acmicpc.net/problem/2869)
"""
문제 설명
땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.
달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.
달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
"""

# 내 풀이
A, B, V = map(int, input().split())

count = ((V - A) // (A - B)) - 2
fin = (A - B) * count
while True :
    count += 1
    fin += A
    if fin >= V :
        print(count)
        break
    else :
        fin = fin - B

# Case Study
a,b,v = map(int,input().split())
k = (v - b) / (a - b)
print(int(k) if k == int(k) else int(k) + 1)

"""
insight 정리
1. 간단한 반복문으로 해결될 것으로 예상했으나, 매우 큰 수에 대한 연산에서는 다른 대안이 필요했었던 문제
2. 앞 부분의 과정은 직접 연산하고 최종 과정에 대해서만 반복문 적용 (정상에 올라간 후에는 미끄러지지 않는다는 특이 사항에 대응하기 위해) ->
계산식을 A * K - B * (K - 1) >= V으로 두면 정상에 올라간 후에는 미끄러지지 않는다는 특이 사항에 대응할 수 있다. 이후 이를 이항 정리하면
K > = (V - B) / (A - B)로 나타낼 수 있다. 이때 나머지 연산이 포함되어 있기 때문에 소수점에 대한 처리가 필요하다. K는 일 수이며 4.1일과 같이 나머지가
발생 할 경우 +1 해야하기 때문에 조건문으로 이를 구분한다.
"""

# ----------------------------------------------------------------------------