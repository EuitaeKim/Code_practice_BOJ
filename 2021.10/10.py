# 1. 1712 - 손익분기점 (https://www.acmicpc.net/problem/1712)
"""
문제 설명
월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료,
재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는
재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.
예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는
총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.

노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면
어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.
최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.

A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.
"""

# 내 풀이
A, B, C = map(int, input().split())
if C - B <= 0 :
    print(-1)
else :
    base = A // (C - B)
    if A + (B * base) < C * base :
        print(base)
    else :
        print(base + 1)
# Case Study

"""
insight 정리
1. 굳이 두번째 if/else문을 만들 필요가 없었음을 체크
왜냐하면 base 값으로 도출되는 몫은 항상 손익분기점에 딱 맞거나 부족하기 때문에
2. ZeroDivisionError를 항상 주의하기
"""

# ----------------------------------------------------------------------------

# 2. 2530 - 인공지능 시계 (https://www.acmicpc.net/problem/2530)
"""
문제 설명
KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다.
인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다.
그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 초 단위로 자동적으로 계산한다. 
또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.  
훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 초 단위로 주어졌을 때,
오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.
"""

# 내 풀이
A, B, C = map(int, input().split())
D = int(input())
total = A * 3600 + B * 60 + C + D
hour = total // 3600
min = (total - (3600 * hour)) // 60
sec = (total - (3600 * hour)) % 60

if min >= 60 :
    min = min % 60
    hour += min // 60

if hour >= 24 :
    hour -= 24 * (hour // 24)

print(hour, min, sec)

# Case Study
h, m, s=map(int,input().split())
s += int(input())
m += s//60
print((h + m // 60) % 24, m % 60, s % 60)

"""
insight 정리
1. 주어진 시, 분, 초를 초 단위로 합쳐서 다시 시, 분, 초를 구함 -> 시, 분, 초를 그대로 가져와서 초 단위부터 연산 진행
2. 단위를 통합시켜 계산하는게 효율적인 줄 알았지만 오히려 시, 분, 초 단위를 그대로 활용하는 것이 적절했음
"""

# ----------------------------------------------------------------------------

# 3. 2292 - 벌집 (https://www.acmicpc.net/problem/2292)
"""
문제 설명
위의 그림과 같이 육각형으로 이루어진 벌집이 있다.
그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.
숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지
(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.
"""

# 내 풀이 GGGGGGGGGGGG..
N = 13
re = N // 6

if 1 <= N <= 7 :
    print(1)
    
def makeli(re) :
    li = [0]
    count = 1
    for i in range(2, re) :
        li.append(count)
        count += i
    return li

li = makeli(re)
print(li.index(re + 1))

# Case Study
n = int(input())
cnt = 1
six = 6
count = 1
while n > cnt :
    count += 1
    cnt += six
    six += 6
print(count)

"""
insight 정리
1. 경로 수를 기준으로 N이 포함 될 최댓값, 최솟값의 규칙을 찾고 이러한 경계값의 리스트를 만든 후 인덱스를 활용해 결과를 추출 (큰 수에서는 작동했지만, 적은 수에서 문제가 생김)
-> 경로 수를 기준으로 각 경로 수 구간에 속하는 값의 '개수'를 계산. 이를 while 문의 조건에서 벗어날 때까지 계산 후 최종 값 출력
2. 주어진 N은 N번째 방이라는 의미이면서 1부터 N까지의 자연수의 counting 값을 의미함.
3. 나는 N을 'value'에만 초점을 두고 사칙연산을 여러 방법으로 적용했지만, N을 'counting'에 초점을 두면 쉽게 풀릴 수 있었음
"""

# ----------------------------------------------------------------------------